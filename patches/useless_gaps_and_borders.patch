--- main_old.c	2025-04-22 15:56:51.559481823 -0000
+++ main.c	2025-04-22 15:55:40.146150816 -0000
@@ -14,6 +14,10 @@
 #define MAX_DESKTOPS 9
 #define MAX_WINDOWS_PER_DESKTOP 6
 #define MOD_KEY Mod4Mask
+#define GAP_SIZE 10
+#define BORDER_WIDTH 1
+#define BORDER_COLOR_FOCUSED 0xFFFFFF
+#define BORDER_COLOR_UNFOCUSED 0x000000
 
 typedef struct {
   KeySym keysym;
@@ -198,9 +202,9 @@
   }
   XEvent ev;
 send:
-for (long unsigned int i = 0; i < sizeof(ev) / sizeof(long); i++) {
-  ((long *)&ev)[i] = 0;
-}
+  for (long unsigned int i = 0; i < sizeof(ev) / sizeof(long); i++) {
+    ((long *)&ev)[i] = 0;
+  }
   ev.type                 = ClientMessage;
   ev.xclient.window       = win;
   ev.xclient.message_type = XInternAtom(dpy, "WM_PROTOCOLS", False);
@@ -298,7 +302,17 @@
   XUnmapWindow(dpy, win);
   tileWindows();
 }
-inline static void focusWindow(Window w) { XSetInputFocus(dpy, w, RevertToParent, CurrentTime); }
+inline static void focusWindow(Window w) {
+  XSetInputFocus(dpy, w, RevertToParent, CurrentTime);
+  for (unsigned char d = 0; d < MAX_DESKTOPS; d++) {
+    Desktop *desk = &desktops[d];
+    for (unsigned char i = 0; i < desk->windowCount; i++) {
+      unsigned long color = (desk->windows[i] == w) ? BORDER_COLOR_FOCUSED : BORDER_COLOR_UNFOCUSED;
+      XSetWindowBorderWidth(dpy, desk->windows[i], BORDER_WIDTH);
+      XSetWindowBorder(dpy, desk->windows[i], color);
+    }
+  }
+}
 static void handleUnmapNotify(XEvent *e) {
   Window win = e->xunmap.window;
   Desktop *d = &desktops[currentDesktop];
@@ -345,28 +359,38 @@
   XCloseDisplay(dpy);
 }
 static void tileWindows(void) {
-  Desktop *d = &desktops[currentDesktop];
-  unsigned char count  = d->windowCount;
+  Desktop *d          = &desktops[currentDesktop];
+  unsigned char count = d->windowCount;
   if (count == 0) return;
+  int outer_gap = GAP_SIZE;
+  int inner_gap = GAP_SIZE;
   unsigned char masterCount = count > 1 ? 1 : 0;
   unsigned char stackCount  = count - masterCount;
   int masterWidth = (screen_width + (resizeDelta << 1)) >> 1;
   if (masterWidth < 100) masterWidth = 100;
   if (masterWidth > screen_width - 100) masterWidth = screen_width - 100;
   int stackWidth   = screen_width - masterWidth;
-  int masterHeight = screen_height / masterCount;
   int stackHeight  = screen_height / stackCount;
+  int usable_width  = screen_width - (2 * outer_gap);
+  int usable_height = screen_height - (2 * outer_gap);
+  int gapped_master_width = masterWidth - outer_gap - (inner_gap / 2);
+  int gapped_stack_width  = stackWidth - outer_gap - (inner_gap / 2);
   if (count == 1) {
-    XMoveResizeWindow(dpy, d->windows[0], 0, 0, screen_width, screen_height);
+    XMoveResizeWindow(dpy, d->windows[0], outer_gap, outer_gap, usable_width, usable_height);
     XRaiseWindow(dpy, d->windows[0]);
     return;
   }
   if (masterCount > 0) {
-    XMoveResizeWindow(dpy, d->windows[0], 0, 0, masterWidth, masterHeight);
+    XMoveResizeWindow(dpy, d->windows[0], outer_gap, outer_gap, gapped_master_width, usable_height);
   }
   for (unsigned char i = 0; i < stackCount; i++) {
-    XMoveResizeWindow(dpy, d->windows[i + masterCount], masterWidth, i * stackHeight, stackWidth,
-                      stackHeight);
+    int stack_y      = outer_gap + (i * (stackHeight + inner_gap));
+    int stack_height = stackHeight - inner_gap;
+    if (i == stackCount - 1) {
+      stack_height = usable_height - (i * (stackHeight + inner_gap));
+    }
+    XMoveResizeWindow(dpy, d->windows[i + masterCount], outer_gap + gapped_master_width + inner_gap,
+                      stack_y, gapped_stack_width, stack_height);
   }
   XRaiseWindow(dpy, d->windows[0]);
 }
